<!DOCTYPE html>
<html>

<head>
  <title>Pirogov CS/Dev</title>
  <!-- Custom CSS -->
  
    <link rel="stylesheet" href="/style/general.css">
    <link rel="stylesheet" href="/style/articles.css">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="icon" href="/public/img/logo.jpg">
</head>

<body>
  <header>
    <div id="header-container">
        <nav>
            <a href="/articles/">Посты</a>
            <a href="/logs/index.html">Логи</a>
        </nav>
    </div>
</header>
    <main id="content-container">
      <article>
        <h2><b>16.03.2023</b></h2>
        <h2>Общая рефлексия</h2>
        <p>
          За данный период изучалось представление программ на языке ассемблера.
        </p>
        <p>
          Компьютеры выполняют машинный код – последовательность байтов, представляющие низкоуровневые операции, которые
          манипулируют данными.
          Компилятор GCC C генерирует на выходе ассемблерный код – текстовое представление машинного кода, – содержащий
          последовательность программных инструкций.
        </p>
        <p>
          Особенности машинного кода. Во-первых, формат и поведение машинной программы зависят от архитектуры набора
          команд (Instruction Set Architecture, ISA), определяющей состояние процессора, формат инструкций и влияние
          каждой из этих инструкций на состояние.
          Во-вторых, адреса памяти, используемые машинной программой, являются виртуальными, благодаря чему
          обеспечивается представление памяти как очень большой массив байтов.
          Одна машинная инструкция может исполнить только очень простую операцию над данными, которыми могут быть
          константами,
          данными в регистрах или памяти. Результат операции обычно помещается в регистры.
          <br>
          Также имеются операции перехода, которые имитируют циклы и условные ветвления. Для проверки условий имеются
          специальные условные флаги.
        </p>
        <p>
          Для функций используется память в виде стека. Аргументы стека хранятся в регистрах, локальные переменные
          хранятся в кадрах стека.
          Также имеются понятия "сохраняемый вызываемый" и "сохраняемый вызывающим" -- сохранения значения регистров,
          если вызывается новая
          функция. Это нужно для того, что значения в регистрах не затиралось при вызове функции. Память стека
          уменьшается с каждым вызовом.
          Для каждой функции выделяется новое место для стека.
        </p>
        <p>
          За данный период читал ассемблерный код, видоизменял циклы и условия, чтобы посмотреть на изменения
          ассемблерного кода.

        </p>
        <h2>13.03.2023</h2>
        <h3>Архитектура компьютера</h3>
        <p>
          Изучил главу про основную память в архитектуре компьютера.
          Ничего нового не узнал, лишь закрепил материал.
          <br>
          <br>
          Изучил главу HCL "Комьютерные системы". Материл был о работае логических винтелей,
          как они формируют блоки и мультиплексоры.
          Была затронута тема регистров. Говорилось об аппаратных регистрах и программных регистрах.
          Разницу слабо понял.
        </p>
        <h3>Go</h3>
        <p>
          Убил 8 часов на поиск бага. Баг оказался в неправильно прочитанном задании.
          Собираюсь выписывать формально требования, ибо это уже не первый раз когда я читаю
          спецификацию подобным образом.
        </p>
        <h2>12.03.2023</h2>
        <h3>
          Процессоры в компьютерных системах
        </h3>
        <p>
          По книге "компьютерные системы" Брайанта ознакомился с ограниченным набором команд для
          создания собственного процессора. С ассемблером очень слабо знаком, но смысл и назначение команд,
          регистров пониманию.
          <br>
          Переключился на Таненбаума "Архитектура компьютера". Изучил "строение" ЦП,
          архитектуры RISC/CISC, алгоритм выполнения команд, понятие "конвейер".
          Важное следствие из изученного состоит в том, что чем больше ЦП может запускать команд
          в один тракт данных, тем более производительным он будет.
          <br>
          Также затронул тему параллелизма на уровне команд и на уровне процессора.
          Параллелизм на уровне команд заключается в помещение команд на конвейер, который
          содержит блоки, каждый из которых исполняет одну операцию (прочитать команду из памяти, декодирование и т.д.)
          Относительно параллелизма на уровне процессоров могу сказать лишь то, что он заключается в
          увеличение количество процессоров. Нужно подробнее изучить данную тему.
          <br>
          <br>
          <b>Повторить тракт данных + параллелизм на уровне процессоров</b>
        </p>
        <h3>
          Go.
        </h3>
        <p>
          Продолжаю практиковаться в Go.
          Изучаю пакет chi, пакеты тестирования.
        </p>
      </article>

    </main>

  </body>

</html>