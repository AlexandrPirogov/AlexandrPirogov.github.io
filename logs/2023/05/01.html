<!DOCTYPE html>
<html>

<head>
  <title>Pirogov CS/Dev</title>
  <!-- Custom CSS -->
  <link rel="stylesheet" href="/style/articles.css">
  <meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="icon" href="/public/img/logo.jpg">
</head>

<body>
  <header>
    <div id="header-container">
        <nav>
            <a href="/articles/">Посты</a>
            <a href="/logs/">Логи</a>
        </nav>
    </div>
</header>

  <body>
        <main id="content-container">
         <article>
            <h2>01.05.2023 -- 15.05.2023</h2>
            <h2>Общая рефлексия</h2>
            <p>
                За данный период было изучено:
                <ul>
                    <li>
                        Структуры операционных систем
                    </li>
                    <li>
                        Понятие процесса и управление процессами
                    </li>
                    <li>
                        Понятие потока
                    </li>
                </ul>
            </p>
            <p>
                <h3>Структуры операционных систем</h3>
                ОС -- среда, предоставляющая функциональность для исполнения программ и запросов пользователей. Функциональность можно разделить на следующие группы:
                <ul>
                    <li>Исполнение программ</li>
                    <li>Обработка операций ввода/вывода</li>
                    <li>МАнипуляция файловой системой</li>
                    <li>Межпроцессорное общение</li>
                    <li>Обработка исключительных ситуаций</li>
                    <li>Выделение ресурсов</li>
                    <li>Логгирование</li>
                    <li>Защита и безопасность</li>
                </ul>
            </p>
            <p>
                Чтобы воспользоваться вышеуказанной функциональностью, ОС предоставляет системные вызовы. 
                Системные вызовы разделяются на следующие основные категории:
                <ul>
                    <li>Управление процессами</li>
                    <li>Управление файлами</li>
                    <li>Управление периферийными устройствами</li>
                    <li>Межпроцессорная коммуникация</li>
                    <li>Безопасность</li>
                </ul>
            </p>
            <p>
                Также были изучены основные архитектуры операционных систем:
                <ul>
                    <li>
                        Монолитная -- кладем весь код в один файл. Тяжело поддерживать и расширять.
                    </li>
                    <li>
                        Уровневый подход -- каждый слой имеет определенную функциональность.
                        Легко поддерживать, но исполнение системных вызовов медленее, нежелеи у монолитной версии.
                    </li>
                    <li>
                        Микроядра -- процессор только ответственнен за общение процессов, которые 
                        располагаются в user-level памяти .
                    </li>
                    <li>
                        Модульные -- ядро имеет основную функциональность, плюс можно добавить дополнительную
                        функциональность в райнтайм в виде модулей.
                    </li>
                </ul>
            </p>

            <h2>Процессы в ОС</h2>
            <p>
                Процесс -- программа в исполнении (загруженная в память).
                Процесс в памяти отражается в виде слоев, которые содержат:
                <ul>
                    <li>text -- код программы (фикс. размер)</li>
                    <li>data -- глобальные переменные</li>
                    <li>stack -- область памяти для функций, растет в сторону убывания адресов</li>
                    <li>heap -- область памяти для выделения памяти во время выполнения программы.
                        растет в сторону возрастания адресов.
                    </li>
                </ul>
                OC ответственная за то, чтобы heap и stack не перекрыли друг друга.
            </p>
            <p>
                Процессы могут находиться в одном из следующих состояний:
                <ul>
                    <li>
                        new -- новосозданный процесс
                    </li>
                    <li>
                        ready -- процесс, готовый к исполнению
                    </li>
                    <li> 
                        running -- процесс, исполняющийся на ядре
                    </li>
                    <li>
                        waiting -- процесс ожидает некоторого ивента (I/O request)
                    </li>
                    <li>
                        terminated -- процесс завершил исполнение
                    </li>
                </ul>
            </p>
            <p>
                Процесс представляется операционной системой в виде блока контроля процесса (process control block).
                Блок содержит:
                <ul>
                    <li>
                        Состояние процесса
                    </li>
                    <li>
                        Счетчик инструкций
                    </li>
                    <li>
                        Регистры ЦП
                    </li>
                    <li>
                        Информация планирования ЦП
                    </li>
                    <li>
                        Информация по управлению памятью
                    </li>
                    <li>
                        Статус I/O 
                    </li>
                </ul>
            </p>
            <p>
                Как только процесс начинает исполнение, он помещается в ready queue, где ожидает, когда он будет присвоен ядру.
                Очередь хранит список control process block. 
                ОС также имеет иные очереди. Например, если исполняющийся процесс ждет завершения операции ввода/вывода, то он помещается 
                в так называемую waiting queue. 
                Также могут быть очереди для процессов, которые исполнялись больше отведенного времени, или очереди для процессов, 
                которые ожидают завершение работы дочерних процессов.
            </p>
            <p>
                Поскольку процессы постоянно сменяются, то ОС должна сохранить состояние текущего процесса, и восстановить состояние 
                новопришедшего процесса. Состояние храниться в process control block.
            </p>
            <p>
                Такж было изучение межпроцессорное общение. 
                Основные механизмы межпроцессорного общения:
                <ul>
                    <li>
                        Разделенная память -- процессы работают с одним участком памяти. 
                    </li>
                    <li>
                        Message-passing -- процесс посылает сообщение в "почту", откуда иной процесс может прочитать сообщение.
                    </li>
                </ul>
                Разделенная память быстрее отправки сообщений за счет того, что в нее вовлечено минимум системных вызовов и работа 
                происходит в одном участке памяти, но синхронизация работы процессов лежит на ответственности разработчика.
                Отправка сообщений решает вопрос безопасности, но работает медленее, и подразумевает лишь отправку небольших сообщений.
            </p>
            <p>
                Последнее, про потоки. Поток -- логический поток инструкций, базовые единица загрузки ЦП. 
                Использование потоков предпочтительнее использования процессов для достижения цели параллельного пррограммирования,
                поскольку switch-context потоков значительнее дешевле, нежели switch_context процессов.  
            </p>
            <p>
                Потоки можно разделить на пользовательские и потоки ядра. 
                Существуют следующие модели маппинга пользовательских потоков в потоки ядра:
                <ul>
                    <li>
                        many-to-one -- множество пользовательских потоков может быть присоединено одному потоку ядра. 
                        Достоинства данного подхода заключается в том, что мы можем создать множества пользовательских потоков. 
                        Недостатком же является то, что если один поток запросит долгий системный вызов потока ядра, то 
                        остальные пользовательские потоки вынуждены будут ожидать. 
                    </li>
                    <li>
                        one-to-one -- каждый пользовательский поток имеет соответствующий поток ядра. 
                        Этот подход применен в большинстве современных ОС. Плюсом данного подхода является возможность 
                        исполнять длительную операция потока ядра и одновременно с этим исполняться другим потоком.
                        Недостатком же является то, что мы ограничены в количестве потоков
                    </li>
                    <li>
                        many-to-many -- модель, которая мультиплексирует пользовательские потоки на меньшее или равное 
                        количество потоков ядра. Это подход устраняет недостатки вышеприведенных моделей, но она сложнореализуема.
                    </li>
                </ul>
            </p>
         </article>
        </main>
  </body>

</html>