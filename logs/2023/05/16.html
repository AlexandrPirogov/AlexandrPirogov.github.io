<!DOCTYPE html>
<html>

<head>
  <title>Pirogov CS/Dev</title>
  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
    integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
  <!-- Custom CSS -->
  <link rel="stylesheet" href="/style.css">
  <meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="icon" href="/public/img/logo.jpg">
</head>

<body>
  <header>
    <h1>Pirogov CS/Dev</h1>
    <nav>
      <ul>
         
        <li><a href="/logs">Логи</a></li>
    </ul>
    </nav>
  </header>

  <body>
    <div class="row">
      <div class="column left">
        <main>
         <article>
            <h2>16.05.2023 -- 31.05.2023</h2>
            <h2>Общая рефлексия</h2>
            За данной период было изучено:
            <ul>
                <li>
                    Вопросы планирования процессов
                </li>
                <li>
                    Инструменты синхронизации процессов
                </li>
                <li>
                    Взаимоблокировки процессов
                </li>
            </ul>

            <h3>Планирование процессов</h3>
            <p>
                Задача планирования процессов состоит в том, чтобы дать каждому процессу выполнить часть своей задачи, что в свою очередь повышает
                уменьшает время отклика системы и позволяет несколько процессам исполняться одновременно. Для решения задачи планирования нужно
                выбрать подходящий алгоритм. Поскольку различные алгоритмы могут различаться между собой, а также могут быть пригодны как для одной 
                системы, но непригодны для другой, выделяют следующие основные критерии для алгоритма планирования:
                <ul>
                    <li>
                        Нагрузка на ЦП -- желательно, чтобы ЦП как можно меньше простаивал
                    </li>
                    <li>
                        Пропускная способность -- количество процессов, которые были назначены ядру 
                        за определенный промежуток времени
                    </li>
                    <li>
                        Время обработки процесса -- время, требующееся, чтобы процесс полностью выполнил свою работу.
                        Это может быть сумма времени, проведенного в ожидании и времени выполнения.
                    </li>
                    <li>
                        Время ожидания -- как долго процесс ожидает прежде чем его назначат ядру.
                    </li>
                    <li>
                        Время отклика -- время, требующееся, чтобы процесс выдал некий результат, возможно промежуточный.
                    </li>
                </ul>
            </p>
            <p>
                Были изучены основные следующие алгоритмы планирования:
                <ul>
                    <li>FCFS (first-come first-serv)</li>
                    <li>Алгоритм приоритетов</li>
                    <li>Round-robin</li>
                </ul>
                Алгоритмы также могут быть:
                <ul>
                    <li>Невытесняющие -- если процессу было выделено ядро, он исполняется до тех пор, пока не выполнит свою работу</li>
                    <li>Вытесняющие -- исполняющийся процесс может быть вытеснен иным процессом по различным причинам</li>
                </ul>
            </p>
            <h4><b>FCFS</b></h4>
            <p>
                Простой невытесняющий алгоритм, подразуемвающий, что первый процесс, поступивших в ready queue будет обслужен.
                <br><br><b>Достоинства</b>
                <li>Прост в реализации</li>
                <br><b>Недостатки</b>
                <li>Высокое время ожидание</li>
                <li>Высокое время отклика</li>
                <li>Низкая пропускная способность</li>
                <li>Возможность возникновения convoy effect</li>
            </p>
            <h4> <b>Алгоритмы с приоритетами</b></h4>
            <p>
                Суть состоит в том, что каждому процессу назначается некоторый 
                приоритет. Приоритет может быть чем угодно, зависит от ОС. Например может быть тип процесса (I/O bound или CPUbound), или 
                назначен приоритет процессов "вручную" . Изначально исполняются процессы с наиболее высоким приоритетом. 
                Алгоритм может быть как невытесняющим, т.е. процесс, назначенный ядру, исполняется до момента завершения своей работы, и 
                вытесняющим, что означает, что процесс может быть вытеснен новоприбывшим алгоритмом с более высоким приоритетом. 

                <br><br><b>Достоинства</b>
                <li>Решает проблему convoy effect</li>
                <li>Время отклика и ожидания в среднем ниже, нежели у FCFS</li>
                <li>Гибкий -- в зависимости от того, что есть приоритет, алгорти можно легко настраивать</li>
                <br><b>Недостатки</b>
                <li>
                    Процессы с низким приоритетом могут долго ожидать ядра, посему требуются дополнительные механизмы 
                    для решения данной проблемы
                </li>
                <li>
                    Хоть гибкость является достоинством, неверный выбор, что будет приоритетом может серьезно сказаться на 
                    эффективности алгоритма.
                </li>
            </p>
            <h4><b>Round robin</b></h4>
            <p>
                RR -- вытесняющий алгоритм, который предоставляет на исполнение каждому процессу небольшое количество времени называемое квантум.
                По мере истечения квантума, процесс будет вытеснен иным процессом, а сам будет помещен в очередь ожидающих процессов. 
                <br><br><b>Достоинства</b>
                <li>Обладает низким временем отлика</li>
                <li>Обладает низким временем ожидания</li>
                <li>ЦП всегда находится в работе</li>
                <br><b>Недостатки</b>
                <li>
                    Очень зависит от размерностью квантума. Слишком маленькое значение приведет к постоянному context-switch.
                    Слишком большое -- снижению эффективности алгоритма.
                </li>
                <li>
                    Сложности, связанные, что делать с вытесненным процессом -- помещать его в конец очереди, или, в комбинации с 
                    алгоритмом приоритетов, поместить в очередь с приоритетом? В первом случае, снижается время отликла, во-втором -- 
                    требуюся дополнительные механизмы. 
                </li>
            </p>
            <h2>Синхронизация процессов</h2>
            <p>
                В системе, где несколько процессов могут получать доступ и модифицировать разделенные данные, требуется наличие инструментов 
                синхронизации, чтобы данные оставались в согласованном и корректном состоянии. Отсутствие подобных инструментов приводит 
                к так называемой гонки состояний. 
                <br>Область, которые подвержена гонки состояний называется критической областью. Для решения проблем, связанной с критической
                областью, требуется удовлетворить следующим требованиям:
                <ul>
                    <li>
                        Mutual exclusion -- если процесс П исполняется в критической области, то никакой другой процесс не может исполняться 
                        в этой критической области.
                    </li>
                    <li>
                        Progress -- если процесс желает выполнять работу в критической области, в которой нет иного другого процесса, тогда 
                        он может быть выбран среди других процессов, чтобы исполнить работу и выбор не может быть отложен на неопределенный срок.
                    </li>
                    <li>
                        Bounded waiting -- время с момента, когда процесс запросил доступ в критическую область до начала исполнения в критической 
                        области должно быть ограничено.
                    </li>
                </ul>
            </p>
            <p>
                Инструменты синхронизации могут быть разделены на два вида -- поддерживаемые аппаратным обеспеченияем и более высокоуровневые инструменты.
                Инструменты аппаратного обеспечения подразумевает наличие так называемых атомарных операций, которые не могут быть прерываны. Обычно, для 
                использования атомарных операций используются атомарные переменные, которые в основном работает с базовыми типами данных.
                Также низкоуровневая синхронизация предполагает инструменты для синхронизации памяти, так называемые memory barriers. Суть 
                заключается в том, что прежде чем получить доступ к ячейки памяти, система должна убедиться, что все запрашиваемая ячейка памяти 
                имеет консистентное состояние и над ней не воспроизводится никаких операций модификации. 
                <br><br>
                Более высокоуровневые инструменты синхронизации подразумвают использования операций compare_and_swap (оптимальная стратегия)
                и использовния мьютексов и семафор (пессиместичный подход). Подобные инструменты используются для синхронизации доступа к критической области. Несмотря на 
                удобство применения по сравнение с низкоуровневыми инструментами, мьютексы и семафоры могут влечь за собой накладные ресурсы, приводят к 
                "голоданию", их неправильно использование может привести к взаимоблокировке. Также, при использовании мьютекса стоит задаться вопросом, 
                будет ли за него "бороться" множество ресурсов, что может привести к снижению производительности. 
            </p>
            <h4><b>Блокировки</b></h4>
            <p>
                
                <br>Обычно, поток исполняет операцию в следующем порядке:
                <ol>
                    <li>Запросить доступ к ресурсу. Если ресурс занят, то ожидает до тех пор, пока ресурс не будет освобожден.</li>
                    <li>Использование ресурса и выполнение работы</li>
                    <li>Освобождение ресурса</li>
                </ol>
                <br>
                Блокировка -- ситуация в которой поток, находящийся в ожидании, ждет события, которое выведет из состояния ожиданияя, но 
                это событие может возникнуть благодаря иному потоку, который также находится в состоянии ожидании и ждет событий от первого потока. 
                Для блокировки необходимо одновременного выполнения следующих небходимых условий:
                <ol>
                    <li>
                        Наличие разделяемого ресурса, доступ к которому может быть лишь эксклюзинво.
                    </li>
                    <li>
                        Поток должен удерживать ресурс за собой и ожидать освобождение дополнительного ресурса, занятого иным потоком.
                    </li>
                    <li>
                        Отсутствие вытеснения -- если поток ожидает иные ресурсы, занятые иным потоком, то эти ресурсы не могут быть 
                        выделены преждевренно для него
                    </li>
                    <li>
                        Наличие циклического ожидания.
                    </li>
                </ol>
                <br><br>
                Для демонстрации наличие блокировки, используется структура данных "графи выделения ресурсов системы". Вершины в нем состоят из 
                множества ресурсов и множества потоков. Ребро, исходящее ресурса к потоку говорит о том, что поток занял этот ресурс. 
                Ребро, исходящее от потока к ресурсу, говорит, что поток запрашивает данные ресурс. Наличие цикла в данном графе говорит о том, что 
                возможно появление блокировки. 
            </p>
            <p>
                Для борьбы с блокировками требуется либо: 
                <li>Следовать некоторому протоколу, который не позволит появлению блокировок</li>
                <li>Дать возможность системе самой обнаруживать блокировки и восстанавливаться в случае появления оновых</li>
                <br><br>Первый случай подразумевает корректное использовние высокоуровневых инструментов и отсутствие возникновение хотя бы одного 
                из вышеперечисленных необходимых условий возникновения блокировки
                <br><br>Второй случай более интересный. Система должна уметь алгортм для обнаружение блокировки, понимать как часто запускать этот алгоритм, 
                и методы разрешения блокировок. Для обнаружения блокировок используются графы, в которых осуществляется поиск циклов среди потоков и ресурсов. 
                Для разрешения блокировок могут использоваться одни из следующих стратегий:
                <li>Завершение всех потоков, которые оказались в блокировке, что влечет за собой серьезные накладные расходы</li>
                <li>
                    Завершение по одному потоку среди потоков, которые оказались в блокировки. Тут сложность возникает в выборе, какой поток выбрать для завершения, 
                    как долго "выключать" потоки, и как восстанавливать потоки. 
                </li> 
            </p>
            
         </article>
        </main>
      </div>

    </div>
    <!-- Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
      integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"
      crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"
      integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1"
      crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
      integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"
      crossorigin="anonymous"></script>
  </body>

</html>