<!DOCTYPE html>
<html>

<head>
  <title>Pirogov CS/Dev</title>
  <!-- Bootstrap CSS -->
  
  <!-- Custom CSS -->
  
    <link rel="stylesheet" href="/style/general.css">
    <link rel="stylesheet" href="/style/articles.css">
  <meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="icon" href="/public/img/logo.jpg">
</head>

<body>
  <header>
    <div id="header-container">
        <nav>
            <a href="/articles/">Посты</a>
            <a href="/logs/">Логи</a>
        </nav>
    </div>
</header>

  <body>
        <main id="content-container">
         <article>
            <h2>01.06.2023 -- 15.06.2023</h2>
            <h2>Общая рефлексия</h2>
            <p>
                За данный период было изучено управление памятью посредством ОС. 
                Большинство систем позволяют пользовательскому процессу находиться в любой части физической памяти.
                Одна из стратегий выделения памяти процессу заключается в задании ему базового регистра и лимитного. Таким образом, 
                образуется memory hole -- структура данных, которая хранит исполняющиеся процессы и участки "свободной памяти".
                Если для процесса, готового к исполнению имеется достаточно места в памяти, то он помещается в нее, иначе ожидает 
                появления свободного места. Обычно память разбита на несколько блоков фиксированного размера, дабы разделить рабочее пространтсова процессов.
                Данный метод хоть и простой, но ведет к проблемам внешней и внутренней фрагментации. Когда процесс занимает слишком малое пространство в блоке, из-за чего мы имеем неиспользующуюсю память, это есть внутреннея фрагментация. Внешняя фрагментация подразумевает, что в памяти в совокупности имеется место для процесса, но поскольку расположение процесса в адресе происходит последовательно, он не может быть помещен не в один из блоков.
            </p>
            <p>
                Поскольку процесс находиться в главной памяти во время исполнения, его данные и инструкции, исполняемые над этими данными,
                должны быть как-то привяза к соответствующим адресам. Связывание адресов может происходить по следующим трем сценариям:
                <ul>
                    <li>
                        Время компиляции. Если известно во время компиляции, где процесс будет находиться в памяти, 
                        тогда можно сгенерировать абсолютный код. Например, если вы знаете, 
                        что пользовательский процесс будет находиться начиная с местоположения R, 
                        то сгенерированный код компилятора будет начинаться с этого местоположения и расширяться оттуда.
                        Если через какое-то время начальное местоположение изменится, то необходимо будет перекомпилировать этот код.
                    </li>
                    <li>
                        Время загрузки. Если во время компиляции неизвестно, где процесс будет находиться в памяти, 
                        компилятор должен сгенерировать перемещаемый код. В этом случае окончательная привязка откладывается до времени загрузки. 
                        Если начальный адрес изменится, нам нужно только перезагрузить код пользователя, чтобы включить это измененное значение.
                    </li>
                    <li>
                        Время исполнения. Если процесс может быть перемещен во время его выполнения из одного сегмента памяти в другой, 
                        то связывание должно быть отложено до времени выполнения. 
                        Для работы этой схемы должно быть доступно специальное оборудование. Большинство операционных систем используют этот метод.
                    </li>
                </ul>
            </p>
            <p>
                Если для первых двух способов фактической разницы между виртуальной и физической памятью не наблюдается, то в последнем
                случае идет явное расхождение ними. Тут сталкиваются с двумя следующими вопросамИ, которые нужно решить:
                <ol>
                    <li>как связать виртуальные адреса с физическими?</li>
                    <li>как решить вопросы с внешней и внутренней фрагментацией?</li>
                </ol>
            </p>
            <p>
               Для решение обоих этих проблем, вводятся следующие данные:
               <ul>
                <li>
                    Фрейм и страница -- физическая и логическая единица данных соответственно
                </li>
                <li>
                    Структура данных таблица страниц.
                </li>
               </ul> 
            </p>
            <p>
                Суть заключается в следующем. Для хранения процесса, он разбивается на страницы, которые будут отображены в физическую память посредством таблицы страниц. Таблицы страниц могут быть следующего типа:
                <ol>
                    <li>
                        Иерархичные -- многоуровневые таблицы страниц. Одна общая таблица страниц может занимать непозволительно много места. Имея одну небольшую "внешнюю" таблицу страниц, похожу на индексы в БД, которая ссылается не внутренние таблицы страниц каждого процесса. Данный метод может экономить используемую память, но поиск страницы может увеличиться.
                    </li>
                    <li>
                        Хэш-таблицы -- для каждой сгененированной страницы имеется хэшированное значение в таблице, ключ которого есть связные список коллизий. Это хороший пример комбинирования структур данных, очень похожий на обработчики исключений. Данный метод значительно экономит место памяти для выделения таблицы страниц, но за счет коллизий время поиска фрейма может вырасти значительно
                    </li>
                    <li>
                        Инвертированные -- хранить для каждого процесса свою таблицу страниц может показаться затратным. Данная стратегия предлагает создать общую таблицу страниц, которая отражается в физическую память, и хранит идентификатор процесса, который использует соответствующую ячейку памяти. Данный метод опасен тем, что процессы разделяют общую ячейку памяти, из-за чего могут быть гонки состояний и иные проблемы параллельного программирования.
                    </li>
                </ol>
            </p>
            <p>
                Также было изучено понятие page swapping, но ничего нового из материала для себя не получил.
            </p>
            
         </article>
        </main>
  </body>

</html>