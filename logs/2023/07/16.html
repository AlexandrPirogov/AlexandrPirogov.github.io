<!DOCTYPE html>
<html>

<head>
  <title>Pirogov CS/Dev</title>
  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
    integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
  <!-- Custom CSS -->
  <link rel="stylesheet" href="/style.css">
  <meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="icon" href="/public/img/logo.jpg">
</head>

<body>
  <header>
    <h1>Pirogov CS/Dev</h1>
    <nav>
      <ul>
         
        <li><a href="/logs">Логи</a></li>
    </ul>
    </nav>
  </header>

  <body>
    <div class="row">
      <div class="column left">
        <main>
         <article>
            <h2>16.07.2023 -- 30.07.2023</h2>
            <h2>Общая рефлексия</h2>
           <p>
            За данный период было изучено устройство файловой системы в ОС, а именно:
            <ol>
                <li>
                    Способы реализации файловой системы
                </li>
                <li>
                    Внутреннее устройство файловой системы
                </li>
            </ol>
           </p>
           <h3>   Способы реализации файловой системы</h3>
           <p>
            Поскольку ПК могут хранить информацию на различных девайсах, для удобства использования, 
            компьютерные системы абстрагируются от физических свойств девайсов, предоставляя единую форму логической единицы представления хранимой информации в виде файла.
            Файл -- именованная коллекция связанной информации, интерпретация которой зависит от разрешения файла (.txt, .o etc).
            С точки зрения пользователя, файл — это наименьшая часть логического вторичного хранилища.
        </p>
    <p>
    Основные атрибуты файла: имя, идентификатор, тип, местоположение, размер, защита, метаданные времени. 
    Информация обо всех файлах хранится в структуре директории, которая находится на том же устройстве, что и сами файлы.
    Прежде чем работать с файлом, его следует открыть (open() sys call), указав его местоположение и имя. 
    Чтобы избежать линейного поиска файла, используется структура данных "open-file table", которая содержит информацию об открытых файлах. 
    При выполнении операции над файлом, с помощью индекса находят его в таблице файлов. 
    После использования файла, его запись удаляется из таблицы открытых файлов.
    Поскольку несколько процессов могут обращаться к файлам, требуется корректный механизм для работы с таблицей файлов. 
    Обычно, ОС использует два уровня внутренних таблиц: per-process и system-wide tables. 
    PP таблиц отслеживает все файлы, которые процесс открыл; в ней хранится информация об использовании файла процессом. Каждая запись PP указывает на system-wide open-file table, которая хранит информацию независимую от процесса, как например местоположение файла на диске, размер файла и т.д. Когда файл открывается процессом, system-wide table добавляет запись для данного файла. Когда новый процесс открывает тот же файл, новая запись добавляется в PPT, которая указывает на ту же запись в SWT. Open-file table обычно хранит количество процессов, которые открыли файлы. close() -- уменьшает это количество, open() -- увеличивает.



            Тип файла можно воспринимать как "подсказку" для программы, и не поддерживает непосредственно самой ОС. 
            Причина по которой ОС не поддерживает несколько файловых структур заключается в громоздкости подобного решения. С единой файловой структурой проще работать, а тип файла подскажет, как обработать конкретный файл.
           </p>
           <p>
            Стоит сказать о возможных структурах для реализации директории:
            <ol>
                <li>
                    single-level -- когда существует один уровень директорий и они содержат только файлы
                </li>
                <li>
                    two-level -- для каждого пользователя создается отдельная директория UFD посредством MFD. 
                </li>
                <li>
                    Tree-structure -- директории представлены в виде дерева. Реализована в большинстве ОС.
                </li>
            </ol>
           </p>
           <p>
            Природа прямого доступа на вторичное устройство хранения дает нам гибкость в реализации файлов. В большинстве случаев файлы хранятся на одном устройстве. Основной вопрос заключается в том, как выделять память/пространство (space) для файлов, so that storage space could be used effectively,
            и файлы можно получить быстро. Используются три основных метода: продолжительный, связный и индексированный.
           </p>
           <p>
            <strong>Contigiuous allocation</strong>

            Суть заключается в размещении FCB (File-Control Block) на вторичном устройстве хранения последовательно. Чтобы прочитать FCB файла, достаточно иметь адрес первого FCB и количество таких FCB. Простая реализация, но имеются следующие недостатки:
            <br>1) тяжело найти последовательность свободного пространства для большого количество FCB. 
            <br>2) Со временем возникают проблемы внешней фрагментации, когда общее количество свободных FCB достаточно, чтобы удовлетворить запрос, но из-за того, что они разбиты на небольшие чанки, мы не можем выполнить его.
            
            
           </p>
<p>
    <strong>Linked allocation</strong>
    Иной спосок для выделение места на диске заключается в том, что каждый блок может располагаться где угодно на диске. Каждый блок имеет указатель на следующий блок. Чтобы прочитать файл, директория содержит указатель на первый и последний блоки. Таким образом мы избавляемся от внешней фрагментации, но часть места на диске уходит на хранение указатель. К тому же возникает вопрос надежности хранение: есть вероятность, что указатель может быть поврежден.
    Ещё один недостатком является возможность лишь последовательного чтения блоков. Это влечет и лишние операции IO, и повышенное время.
    Одна разновидность реализации данного метода подразумевает использование file-allocation table (FAT) -- таблица, содержащая в качестве ключа -- индекс блока, а в качестве значения -- значение следующего связного блока. Если значение пусто, то означает, что это конец файла. Таблица хранится на устройстве хранение, поэтому из-за операций ввода-вывода скорость поиска может быть не столь эффективной. если бы таблица хранился в памяти/кэше.
    
</p>
<p>
    <strong>Index allocation</strong>

    Поскольку linked allocation страдает доступом по индексу, тут рождается новый метод, который собирает все указатели воедино в блоке индексов. Директория владеет блоком индексов и с помощью его может прямо обращаться к блокам файлов. Проблема заключается в том, насколько большим должен быть блок индексов. Тут применяются следующие методы:
    <ol>
        <li>
            Блок индексов остается небольшого размера, и его последний указатель, если указателей не хватает для блоков файлов, 
            указывает на следующий блок индексов.
        </li>
        <li>
            Многоуровневый блок индексов. Указатели первого блока индексов могут указывать на последующие блоки индексов, 
            указатели которых в свою очередь указывают непосредственно на данные. Эта схема может иметь несколько уровней.

        </li>
        <li>
            Комбинированный подход, используемый в UNIX. Блок индексов первого уровня содержит 15 указателей, 
            12 из который указывают на данные файла. 13 блок указывает на следующий блок индексов, указатели которого указывают на данные. 14 и 15 блоки указывают на 2-х и 3-х уровневые блоки индексов соответственно.
    
        </li>
    </ol>
       
</p>


<p>

При выборе алгоритма важно понимать, в какой системе будет использоваться алгоритм: алгоритм последовательного доступа будет не лучшим выбором, для систем с рандомным доступом и наборот
           </p>
           <p>
            <strong>По итогу:</strong>
            <ul>
                <li>
                    Файл -- АТД определен и реализован ОС; последовательность логических записей, которые могут быть байтом линией или иным предметом. 
                    ОС может поддерживать специально определенные типы записей, а может оставить это дело прикладным программам
                </li>
                <li>
                    Основная задача ОС -- отразить концепцию логического файла на физический девайс (HDD). 
                    Поскольку размер физической записи может не совпадать с размером логической записи, может быть необходимо упорядочить логические записи в физические записи.
                </li>
                <li>
                    Внутри файловой системы может быть полезно создавать директории для организации файлов. 
                    В основном используются древовидные структуры. Ацикличный граф позволяет расшаривать файлы в системе. 
                </li>
                <li>
                    ОС нуждаются в защите доступа к файлам. Доступ к файлом определяется правами и пользователями с помощью ACL
                </li>
            </ul>
           </p>

           <h3>  Внутреннее устройство файловой системы</h3>
           <p>
        Реализация файловой системы включает следующие вопросы:
        <ul>
            <li>
                Как она будет представлена клиенту
            </li>
            <li>
                Какие алгоритмы и структуры данных будут использоваться, чтобы отразить логическую файловую системы в физическую.
            </li>
        </ul>

    Файловая система состоит из нескольких уровней, где каждый уровень использует функции нижележащего уровня:

    <ul>
        <li>
            Уровень I/O контроля состоит из драйвера девайса и обработчика прерываний, 
            чтобы передавать данные между девайсом и памятью. Драйвер девайся выступает в роли транслятора, на вход которого поступают высокоуровневые команды, а на выходе получаются низкоуровневые команды для взаимодействия с девайсом. Глава 12 рассказывает об этом.
        </li>
        <li>
            Basic file-system выдает только общие команды, на основе логических адресов блоков, к подходящим драйверам устройства для чтения и записи блоков на устройстве. Это также связано с планированием I/O операций. Этот уровень управляет буферами памяти и кэшэм, которые содержат различные файловые-системы, директории и блоки данных. Блок в буфере выделяется до того, как может произойти передача блока запоминающего устройства. 
            Когда буфер заполнен, менеджер буфера должен найти больше памяти или освободить буфер, чтобы закончить выполнить IO операцию.

        </li>
        <li>
            File-organization module владеет информацией о файлах и их логических блоков. 
            Каждый блок файла пронумерован от 0/1 до N. Модуль файловой организации также включает диспетчер свободного пространства, который отслеживает нераспределенные блоки и предоставляет эти блоки модулю файловой организации по запросу.

        </li>
        <li>
            Logical file-system управляет метаданными. Метаданные включают всю структуру файловой системы, кроме фактических данных (или содержимого файлов).
            Логическая файловая система управляет структурой каталогов, чтобы предоставить модулю файловой организации необходимую ему информацию, учитывая символическое имя файла. Он поддерживает файловую структуру с помощью блоков управления файлами. Блок управления файлами (FCB) (inode в файловых системах UNIX) содержит информацию о файле, включая владельца, разрешения и расположение содержимого файла.
   
        </li>
    </ul>
       </p>
       <p>
        Для реализации структур данные используются как на диске, так и в памяти компьютера.
       </p>
       <p>
        Обычно компьютеры работают не с одним, а миллионами файлов. 
        Компьютерные системы общего назначения могут иметь несколько вторичных устройств хранения, которые в свою очередь могут разделены на партиции, содержащие тома, которые в свою очередь хранят файловую систему. 
        В зависимости от менеджера томов, том может охватывать несколько партиций.
        Компьютеры могут иметь различное количество файловых систем, которые в свою очередь могут иметь различный тип
       </p>
       <p>
        <strong>По итогу</strong>
        <ul>
            <li>
                Операционные системы общего назначения предоставляют множество типов файловых систем, от специальных до общих.
            </li>
            <li>
                Тома, содержащие файловые системы, могут быть смонтированы в пространстве файловой системы компьютера.
            </li>
            <li>
                В зависимости от операционной системы пространство файловой системы может быть бесшовным (смонтированные файловые системы интегрированы в структуру каталогов) 
                или отдельными (каждая смонтированная файловая система имеет собственное обозначение).
            </li>
            <li>
                По крайней мере одна файловая система должна быть загружаемой, чтобы система могла запускаться, т. е. она должна содержать операционную систему. Загрузчик запускается первым; это простая программа, способная найти ядро в файловой системе, загрузить его и начать выполнение. 
                Системы могут содержать несколько загрузочных разделов,позволяя администратору выбирать, что запускать во время загрузки.
            </li>
        </ul>
       </p>
         </article>
        </main>
      </div>

    </div>
    <!-- Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
      integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"
      crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"
      integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1"
      crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
      integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"
      crossorigin="anonymous"></script>
  </body>

</html>