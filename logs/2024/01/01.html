<!DOCTYPE html>
<html>

<head>
  <title>Pirogov CS/Dev</title>
  <!-- Bootstrap CSS -->
  
  <!-- Custom CSS -->
  
    <link rel="stylesheet" href="/style/general.css">
    <link rel="stylesheet" href="/style/articles.css">
  <meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="icon" href="/public/img/logo.jpg">
</head>

<body>
  <header>
    <div id="header-container">
        <nav>
            <a href="/articles/">Посты</a>
            <a href="/logs/">Логи</a>
        </nav>
    </div>
</header>

  <body>
        <main id="content-container">
            <article>
                <h2>01.01.2024 - 15.01.2024</h2>
                <h2>Общая рефлексия</h2>
                <p>
                    За данный период практиковал использование Kafki в качестве шины и 
                    ознакомился с основными вопросами, касательно проектирования архитектуры с брокером.
                </p>
                <h2>Архитектуры с использованием Kafka</h2>
                <p>
                    Кафка позволяет создавать низкосвязанные между собой сервисы, чем открывает интересные 
                    вариацици использования:
                    <ol>
                        <li>
                            Publish-Subscribe - наиболее простая модель взаимодействия сервисов, где 
                            поставщик посылает сообщения в шину, а потребители считывают сообщения из шины. 
                            Тут важно задуматься о том, какие типы сообщений будут использоваться какими группами потребителей - 
                            это может влиять на количество создаваемых топиков и группы потребителей.
                        </li>
                        <li>
                            Log aggregation - модель, в которой несколько сервисов записывают структурированные логи эвентов 
                            в шину. Топики могут быть разбиты на стадии, если требуется обработать логи. Далее, накопленные логи будут 
                            считаны потребителем и обычно направляются в хранилище данных
                        </li>
                        <li>
                            Log shipping - модель, подразумевающая копирования журнала записи в реальном времени от мастера и его репликам.
                            Это относительно легко достигается благодаря природе упорядочивания сообщений в топиках.
                        </li>
                    </ol>
                </p>
                <p>Также ознакомился с SEDA pipelines, CEP и Event-Sources CQRS моделями, но не могу найти им применения на данный момент...</p>
                <p>
                    Поскольку сообщения раскидываются по партициям, проходя через хэширование функции murmur2, то стоит обратить внимание 
                    на количество партиций при создании топика. Если увеличение количества партиций не столь страшно, то их уменьшение может повлиять 
                    на группировку сообщений и повлиять на природу упорадоченности. Общее правило -- не уменьшать количество партиций.
                </p>

                <h2>Практика</h2>
                <p>
                    Во время практики разрабатывал акторы, создающие и считывающие сообщения из и в шину соответственно. Интересно,
                    что настройка топиков возможна лишь при их создании, но возможно обнаружится настройка в рантайм. 
                    Поэкспереминтировал с сжатием сообщений. Важно отметить, что сжатие повышает связанность между вашими пролижениями, посколкьу
                    kafka не сжимает обычно сообщений (хотя можно настроить), дабы не тратить на это циклы ЦП. 
                </p>
                <p>
                    Также изучал взаимодействие с оффсетами со стороны потребителей - поскольку потребителей может быть несколько, а также 
                    наличие реплик и лидеров, то, как выяснилось, взаимодействие с оффсетами требует особого подхода, дабы не утерять данные.
                </p>
            </article>
        </main>
      </div>
    </div>
  </body>

</html>