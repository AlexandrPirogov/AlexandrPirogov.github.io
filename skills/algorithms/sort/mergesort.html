<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" href="/css/newstyle.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nunito">
<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
</head>
<body>
    <div class="mainText">
        <div class="learnedSkills">
            <div class="routes">
                <div class="route">
                    <h2><a href="/index.html">На главную</a></h2>
                </div>
                
                <div class="route">
                    <h2><a href="../intro.html">Обратно</a></h2>
                </div>
            </div>
            <h1>Сортировка слиянием</h1>
            <div>
                <p>
                    Сортировка слиянием работает следующим образом: массив, имеющий n элементов разбивается на два равных подмассива. Затем мы разбиваем каждый
                    из двух подмассивов на еще более мелкие подмассивы, и делаем так до тех пор, пока размер каждого подмассива не станет равным 1.
                    Такой вот рекурсивный поход :)
                </p>
                <p>
                    По определению, массив состоящий из одного элемента -- отсортирован. Нам остается "слить" два подмассива в один.
                    Мы выделяем некий буфер, чтобы сохранить результаты "разбитых" массивов. Поскольку "разбитые" массивы -- отсортированы, 
                    то каждый из этим подмассивов будет содержать в качестве первого элемента -- наименьший элемент массива. 
                    Нам остается взять наименьший элемент из соответствующего буфера, до тех пор пока буферы не станут пустыми.
                </p>
            </div>
            <div>
                Общее время исполнения равно O(n* lg n), поскольку:
                <ol>
                    <li>
                        разбивая массив на "подмассивы" мы формируем дерево. Изначально у нас имеется массив из n элементов, уровень k его = 0.
                        Разбивая исходны массив n на два подмассива мы получаем два подмассива размерностью n/2. Его уровень 1. При этом, размер каждого подмассива будет 
                        определяться n/(2^k), где k -- уровень дерева (разбиения, если угодно). Таким образом, до разбиения массивов с размерностью 1, получаем сложность O(lg n).
                    </li>
                    <li>
                        После того, как мы разбили массивы на подмассивы, мы должна собрать каждый подмассив воедино. Для этого, мы проходимся линейно по каждому буферу, из-за чего получаем O(n)
                    </li>
                </ol>
            </div>
            <h2>Реализация</h2>
            <div>
                <pre class="prettyprint">
                    <code>
#define capacity 20
typedef std::array&ltint, capacity&gt array;
typedef std::queue&ltint&gt queue;

void merge(array& arr, int low, int middle, int high)
{
    int i;
    queue buffer1{}, buffer2{};

    for(int i = low; i <= middle; i++)buffer1.push(arr[i]);
    for(int i = middle+1; i <= high; i++)buffer2.push(arr[i]);

    i = low;

    while(!( buffer1.empty()|| buffer2.empty()))
    {
        int tmp;
        if(buffer1.front() <= buffer2.front())
        {
            arr[i++] = buffer1.front();
            buffer1.pop();
        } else {
            arr[i++] = buffer2.front();
            buffer2.pop();
        }
    }

    while(!buffer1.empty())
    {
        arr[i++] = buffer1.front();
        buffer1.pop();
    }

    while(!buffer2.empty())
    {
        arr[i++] = buffer2.front();
        buffer2.pop();
    }
}

void merge_sort(array& arr, int low, int high)
{
    if(low < high)
    {
        int middle = (low+high)/2;
        merge_sort(arr, low, middle);
        merge_sort(arr, middle+1, high);
        
        merge(arr, low, middle, high);
    }
}

                    </code>
                </pre>
            </div>
    </div>   
</body>