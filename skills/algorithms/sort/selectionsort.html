<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" href="/css/newstyle.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nunito">
<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
</head>
<body>
    <div class="mainText">
        <div class="learnedSkills">
            <div class="routes">
                <div class="route">
                    <h2><a href="/index.html">На главную</a></h2>
                </div>
                
                <div class="route">
                    <h2><a href="../intro.html">Обратно</a></h2>
                </div>
            </div>
            <h1>Сортировка выбором</h1>
            <div>
                Сортировка выбором подразуемвает, что мы разделяем контейнер на отсортированную/неотсортированную части. 
                Поиск наименьшего/наибольшего элемента осуществляется в неотсортированной части, что занимает линейное время.
                Найденный наименьший/наибольший элемент меняется местами с элементом массив <i>i (изначально i = 0)</i>. После чего цикл повторяется, до тех пор,
                пока i не станет равным n-1, где n -- размер контейнера.
            </div>
            <div>
                Общее время исполнения равно O(n^2), поскольку:
                <ol>
                    <li>
                        мы выполняем n итераций (количество элементов в неотсортированном массив);
                    </li>
                    <li>
                        для каждой итерации мы выполняем поиск наименьшего/наибольшего элемента, что в среднем составляет n/2.
                    </li>
                </ol>
            </div>
            <h2>Реализация</h2>
            <div>
                <pre class="prettyprint">
                    <code>
#include &ltarray&gt

void selection_sort_asc(std::array&ltint, ARRAY_SIZE&gt& array)
{
    int min = 0;
    for(int i = 0; i < ARRAY_SIZE; i++)
    {
        min = i;
        for(int j = i+1; j < ARRAY_SIZE; j++)
        {
            if(array[j] < array[min])
                min = j;
        }
        swap(array, i, min);
    }
};
                    </code>
                </pre>
            </div>
            <h2>Дополнительные заметки</h2>
            <div>
                <p>
                    Производительность алгоритма сортировки выбором можно улучшить с O(n^2) до O(n*lg n), если в качестве контейнера будет 
                    выступать куча (<i>heap</i>). Такая сортировка также называется пирамидальной сортировкой.
                </p>
                <p>
                    Поскольку время получения минимального/максимального элемента из кучи (будет принимать, что куча -- биномиальная) равно O(lg n),
                    то поиск наименьшего элемента в алгоритме будет равно O(n*lg n).
                </p>
                <p>
                    Подробнее о структуре данной куче можно посмотреть <a href="/skills/datastructures/trees/heaps/binaryheap.html">здесь</a>.
                </p>
            </div>
    </div>   
</body>