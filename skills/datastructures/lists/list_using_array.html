<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" href="/css/newstyle.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nunito">
<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
</head>
<body>
    <div class="mainText">

        <div class="learnedSkills">
            <div class="routes">
                <div class="route">
                    <h2><a href="/index.html">На главную</a></h2>
                </div>
                
                <div class="route">
                    <h2><a href="intro.html">Обратно</a></h2>
                </div>
            </div>
            <div class="СppAndPg">
                <h1>
                    Реализация списка через массив
                </h1>
                <h2>
                    Достоинства и недостатки данной реализации:
                </h2>
                <h3>Достоинства</h3>
                <div>
                    <ol class="advantages">
                        <li>
                            Доступ к элементам по позиции осуществляется за константное время. 
                        </li>
                    </ol>
                </div>
                <h3>
                    Недостатки
                </h3>
                <div>
                    <ol class="disadvantages">
                        <li>
                            При удалении элемента либо приходится заполнять соответствующий индекс "некой" заглушкой.
                        </li>
                        <li>
                            Ограниченный объем для хранения данных.
                        </li>
                        <li>
                            Вставка элемента в середину приводит к сдвигу всех остальных последующих элементов.
                            Удаление также требует смещение элементов.
                        </li>
                    </ol>
                </div>
                <h1>
                    Реализация
                </h1>
                <div>
                    Определим основные операции для АТД Список основанном на массиве.
                    
                    <ol>
                        <li>
                            <span class="atdinterface"><b>insert(x, p)</b></span> -- вставка элемента x на позицию p.
                        </li>
                        <li>
                            <span class="atdinterface"><b>retrieve(x)</b></span> -- поиск элемента x в Списке. Если элемент 
                            найден, то возвращаем соответствующую позицию. 
                            Иначе возвращаем -1.
                        </li>
                        <li>
                            <span class="atdinterface"><b>at(p)</b></span> -- возвращает элемент на позиции p.
                        </li>
                        <li>
                            <span class="atdinterface"><b>delete(p)</b></span> -- удаление элемента в позиции p.
                        </li>
                        <li>
                            <span class="atdinterface"><b>clear()</b></span> -- делает список пустым.
                        </li>
                        
                    </ol>
                </div>
                <h1>Code Example</h1>
                <div>
                    <a class="githubsources" href="https://github.com/eduAlexandrPirogov/abstract_data_structures_implementation/tree/main/cpp_implementation/LinkedListArray"><b>Полный код на гитхабе.</b></a>
                </div>
                <div>
                    Прежде определим интерфейс:
                    <pre class="prettyprint">
                        <code>
typedef long long UL;

const UL LIST_CAPACITY = 10; //Define max list's capacity

/**
* Making our list generic
*/
template &lttypename T&gt
class ListUsingArray
{

    short current_insert_status;
    short current_delete_status;
    short current_retrieve_status;

    UL current_size;
    std::array<T, LIST_CAPACITY> capacity{}; //Our container 
public:
    const short INSERT_STATUS_NIL = -1;
    const short INSERT_STATUS_OK  =  0;
    const short INSERT_STATUS_OUTOFCAPACITY  =  1;
    const short INSERT_STATUS_INCORRECT_INDEX  =  2;

    const short DELETE_STATUS_NIL = -1;
    const short DELETE_STATUS_OK  =  0;
    const short DELETE_STATUS_NOTFOUND  =  0;

    const short RETRIEVE_STATUS_NIL = -1;
    const short RETRIEVE_STATUS_OK  =  0;
    const short RETRIEVE_STATUS_NOT_FOUND = 0;

    ListUsingArray();

    //Pre-cond: given correct pos
    //Post-cond: returned respectful element
    inline const T at(UL pos);

    //Pre-cond: 
    //Post-cond: list is empty
    inline void clear();

    //Pre-cond: elem is existing
    //Post-cond: elem is deleted from lisst and size decreased
    void erase(T t);

    //Pre-cond: pos is existing
    //Post-cond: new elem was added to list and size increased
    void insert(T t, UL pos);

    //Pre-cond: Elem is existing in list
    //Post-cond: Returned copy of elem
    T retrieve(T t);

    inline const UL size();

    inline const short insert_status();

    inline const short delete_status();

    inline const short retrieve_status();

};
                        </code>
                    </pre>
                </div>
                <h3>Реализация метода вставки</h3>
                <div>
                    <p>
                        При вставке элемента на определенную позицию сдвигаем последующие элементу на одну позицию:
                    </p>
                </div>
                <div>
                    <pre class="prettyprint">
                    <code>
template &lttypename T&gt
void ListUsingArray<T>::insert(T t, UL pos)
{
    if(pos < 0 || pos > LIST_CAPACITY-1)
    {
        current_insert_status = INSERT_STATUS_INCORRECT_INDEX;
    } else if (current_size == LIST_CAPACITY)
    {
        current_insert_status = INSERT_STATUS_OUTOFCAPACITY;
    } else 
    {
        for(UL index = current_size; index > pos; index--)
            capacity[index] = capacity[index-1];

        capacity[pos] = t;
        current_insert_status = INSERT_STATUS_OK;
        current_size++;
    }
};
                        </code>
                    </pre>
                </div>
                <h3>Реализация метода поиска элемента</h3>
                <div>
                    <p>
                        Для поиска элемента проходимся по всему массиву и возвращаем искомый элемент.
                        Если элемент не найден -- возвращаем пустой указатель.
                    </p>
                </div>
                <div>
                    <pre class="prettyprint">
                    <code>
template &lttypename T&gt
T ListUsingArray<T>::retrieve(T t)
{
    auto find_result = std::find(capacity.begin(), capacity.end() , t);
    find_result == 0 ?
        current_retrieve_status = RETRIEVE_STATUS_NOT_FOUND
        :
        current_retrieve_status = RETRIEVE_STATUS_OK;
    return *find_result;
};
                        </code>
                    </pre>
                </div>
                <h3>
                    Реализация метода удаления элемента
                </h3>
                <div>
                    <p>
                        При удалении элемента ищем искомый элемент, определяем позицию данного элемента, затем сдвигаем все последующие элементы
                        на одну предыдущую позицию, тем самым удаляя удаляемый элемент. При этом не забываем установить пустой указатель на последний элемент.
                    </p>
                </div>
                <div>
                    <pre class="prettyprint">
                    <code>
template &lttypename T&gt
void ListUsingArray<T>::erase(T t)
{
    auto find_result = std::find(capacity.begin(), capacity.end() , t);
    if(find_result == 0)
    {
        current_delete_status= DELETE_STATUS_NOTFOUND;
    } else 
    {
        UL found_at = std::distance(capacity.begin(), find_result);
        for(UL index = found_at ; index < current_size-2; index++)
        {
            capacity[index] = capacity[index+1];
        }
        current_size--;
        capacity[current_size-1] = *(new T);
        current_delete_status = DELETE_STATUS_OK;
    }
};
                        </code>
                    </pre>
                </div>
            </div>
    </div>   
</body>