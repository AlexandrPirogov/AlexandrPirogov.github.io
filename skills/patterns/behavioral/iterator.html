<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" href="/css/newstyle.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nunito">
<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
</head>
<body>
    <div class="mainText">

        <div class="learnedSkills">
            <div class="routes">
                <div class="route">
                    <h2><a href="/index.html">На главную</a></h2>
                </div>
                
                <div class="route">
                    <h2><a href="../intro.html">Обратно</a></h2>
                </div>
            </div>
            <div class="СppAndPg">
                <h1>Iterator</h1>
                <div>
                    <h2>Что предоставляет?</h2>
                    Предоставляет способ последовательного доступа ко всем элемента составного объекта,
                    не раскрывая его внутреннего представления.
                </div>

                <div>
                    <h2>Применимость</h2>
                    Применяйте данный паттерн когда:
                    <ol>
                        <li>
                            для доступа к содержимому агрегированных объектов без раскрытия их
                            внутреннего представления;
                        </li>
                        <li>
                            для поддержки несколкьих активных обходов одного и того же агрегированного объекта;
                        </li>
                        <li>
                            для предоставления единообразного интерфейса с целью обхода различных агрегированных
                            структур.
                        </li>
                    </ol>
                </div>

                <div>
                    <h2>Мотивация</h2>
                    <p>
                        Составной объект, например дерево, должны предоставлять способ доступа к своим элементам, 
                        не раскрывая собственную структуру. Более того, деревья можно обхожить в ширину или глубину. Подобными
                        операциями не желательнор "засорять класс". К тому же, если мы захотим сагрегировать элементы дерева,
                        то класс быстро засоряется подобными методами.
                    </p>
                    <p>
                        Паттерн "Итератор"  отвечает за предоставление доступа к элементам вместо агрегируемого класса. 
                        В классе "Итератор" определен интерфейс для доступа к элементам списка. Например, для класса дерева мы можем создать два Итератора,
                        один который будет обходить дерево в ширину, а другой -- в глубину.
                    </p>
                </div>

                <div>
                    <h2>Схема</h2>
                    <img class="schemaImage" src="/images/patterns/behavioral/iterator/iteratorschema.png" alt="">
                </div>

                <div>
                    <h2>Source code example</h2>
                    Полный код примера можно увидеть <a href="https://github.com/eduAlexandrPirogov/Patterns/tree/main/behavioral/iterator">на гитхабе</a>.

                    </div>
                </div>
                <div>
                    <pre class="prettyprint">
                        <code>
                            template <typename T>
class Iterable
{
public:
    virtual T begin() = 0;
    virtual T next() = 0;
    virtual bool hasNext() = 0;
};

template&lttypename T&gt
class List
{
    std::list&ltT&gt list;
    
    class Iterator : public Iterable&ltT&gt 
    {
        List* current = 0;
        typename std::list&ltT&gt::iterator iter;
        public:
            Iterator(List* list) : current(list) 
            {
                iter = current->list.begin();
            };

            T begin()
            {
                return *(current->list.begin());
            }

            T next()
            {
                auto oldIter = iter;
                ++iter;
                return *(oldIter);
            }

            bool hasNext()
            {
                return (iter != current->list.end());
            }
    };
    public:
        List() = default;

        void push_back(T t)
        {
            list.push_back(t);
        };

        Iterator* iterator()
        {
            return new Iterator(this);
        }
};

                        </code>
                    </pre>
                </div>
                
                <div>
                    <h2>Последствия применения паттерна</h2>
                    <h3>Преимущества</h3>
                    <ol>
                        <li>
                            поддерживает различные виды обхода агрегата. Сложные агреграты можно 
                            обходить по-разному. Например, деревья можно обходить как в ширину, так и в глубину;
                        </li>
                        <li>
                            итераторы упрощают интерфейс агрегируемого класса, что позволяет избегать засорение
                            методами-агрегатами в классах;
                        </li>
                        <li>
                            как и для одного агрегата может быть нескольк обходов, так и для несколько агрегатов может быть один обход.
                        </li>
                    </ol>
                </div>
            </div>
    </div>   
</body>