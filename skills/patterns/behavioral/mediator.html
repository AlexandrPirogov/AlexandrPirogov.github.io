<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" href="/css/newstyle.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nunito">
<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
</head>
<body>
    <div class="mainText">

        <div class="learnedSkills">
            <div class="routes">
                <div class="route">
                    <h2><a href="/index.html">На главную</a></h2>
                </div>
                
                <div class="route">
                    <h2><a href="../intro.html">Обратно</a></h2>
                </div>
            </div>
            <div class="СppAndPg">
                <h1>Mediator</h1>
                <div>
                    <h2>Что предоставляет?</h2>
                    Определяет объект, инкапсулирующий способ взаимодействия множества объектов.
                    Медиатор обеспечивает слабую связанность системы, избавляя объекты от небходимости явно ссылаться друг на друга и 
                    позволяя тем самым независимо изменять взаимодействия между ними.
                </div>

                <div>
                    <h2>Применимость</h2>
                    Применяйте данный паттерн когда:
                    <ol>
                        <li>
                            имеются объекты, связи между которыми сложны и четко определены.
                            Получающиеся при этом взаимозависимости не структурированы и трудны для понимания;
                        </li>
                        <li>
                            нельзя повторно использовать объект, посколкьу он обменивается информацией со многими
                            другими объектами;
                        </li>
                        <li>
                            поведение, распределенное между несколькими классами, должна поддаваться настройке
                            без порождения множества подклассов.
                        </li>
                    </ol>
                </div>

                <div>
                    <h2>Мотивация</h2>
                    <p>
                        Объектно-ориентированное проектирование способствует распределению некоторого поведения между объектами.
                        Но при этом в получившейся структуре объектов может возникнуть много связей или (в худшем случае) каждому объекту 
                        придется иметь информацию обо всех остальных.
                    </p>
                    <p>
                        Разбиение системы на множество объектов в общем случае повышает степень повторного использования,
                        однако изобилие взаимосвязей приводит к обратному эффекту, к тому же подобную систему становится сложнее тестировать.
                        Допустим, у нас имеется класс Computer, и классы переферийных устройств: мышка, клавиатура, монитур, колонки и т.д.
                        При нажатии на клавишу, текст выводится на экран; регулируется громкость музыкальных колонок.
                        Количество взаимосвязей растет, при этом становится проблемным создавать объекты независимо друг от друга.
                    </p>
                    <p>
                        Всех этих проблем можно избежать, если инкапсулировать коллективное поведение в отдельном объекте-медиаторе.
                        Медиатор отвечает за координацию взаимодействий между группой объектов. Он избавляет входящие в группу объектов 
                        от небходимости ссылаться явно друг на друга.
                    </p>
                </div>

                <div>
                    <h2>Схема</h2>
                    <img class="schemaImage" src="/images/patterns/behavioral/mediator/mediatorschema.png" alt="">
                </div>

                <div>
                    <h2>Source code example</h2>
                    Полный код примера можно увидеть <a href="https://github.com/eduAlexandrPirogov/Patterns/tree/main/behavioral/mediator">на гитхабе</a>.

                    </div>
                </div>
                <div>
                    <pre class="prettyprint">
                        <code>

class Computer 
{
class Mouse* mouse = 0;
class Screen* screen = 0;
class KeyBoard* keyboard = 0;
class SoundBoard* soundBoard = 0;
    public:
    Computer()
    {
        CreateCollegaues();
    }
    void Start()
    {
        std::cout << "Turning on pc...\n";
    }

    void plugInMouse(Mouse* mouse);

    void plugInScreen(Screen* screen);

    void plugInKeyboard(KeyBoard* KeyBoard);

    void plugInSoundboard(SoundBoard* soundboard);
    void ColleagueChanged(Mouse* changed);
    void ColleagueChanged(KeyBoard* changed);

protected:
    void CreateCollegaues();
};


class Colleague
{
public:
    virtual void Changed() = 0;
protected:
    Computer* director = 0;
};


class Screen : public Colleague
{
public:
    Screen(Computer* director)
    {
        this->director = director;
    };

    void showKeyboardClickedButton(char key)
    {
        std::cout << "Button " << key << " was clicked\n";
        Changed();
    }

    void Changed()
    {
        this->director = director;
    }
};

class KeyBoard : public Colleague
{
    char lastKey;
public:
    KeyBoard(Computer* director)
    {
        this->director = director;
    };

    void clickButton(char key)
    {
        lastKey = key;
        Changed();
    };

    const char getClickedKey()
    {
        return lastKey;
    }

    void Changed()
    {
        director->ColleagueChanged(this);
    }
};

class SoundBoard : public Colleague
{
public:
    SoundBoard(Computer* director)
    {
        this->director = director;
    };

    void turnOn()
    {
        std::cout << "Music is playing!\n";
    };

    void turnOff()
    {
        std::cout << "Music is not playing anymore!\n";
    };
     
    void Changed()
    {
        this->director = director;
    }
};

class Mouse : public Colleague
{
    bool isLeft;
public:
    Mouse(Computer* director)
    {
        this->director = director;
    };

    void Changed()
    {
        director->ColleagueChanged(this);
    }

    void ClickedLeft()
    {
        std::cout << "Left Mouse clicked! ";
        isLeft = true;
        Changed();
    }

    void ClickedRight()
    {
        std::cout << "Right Mouse clicked! ";
        isLeft = false;
        Changed();
    }

    bool isLeftClicked()
    {
        return isLeft;
    }
};

void Computer::CreateCollegaues()
{
    mouse = new Mouse(this);
    screen = new Screen(this);
    keyboard = new KeyBoard(this);
    soundBoard = new SoundBoard(this);
};

void Computer::ColleagueChanged(Mouse* changed)
{
    if(changed->isLeftClicked())
    {
        soundBoard->turnOn();
    } else {
        soundBoard->turnOff();
    }
};

void Computer::ColleagueChanged(KeyBoard* changed)
{
    screen->showKeyboardClickedButton(changed->getClickedKey());
};


void Computer::plugInMouse(Mouse* mouse)
{
    this->mouse = mouse;
};

void Computer::plugInScreen(Screen* screen)
{
    this->screen = screen;
};

void Computer::plugInKeyboard(KeyBoard* KeyBoard)
{
    this->keyboard = keyboard;
};

void Computer::plugInSoundboard(SoundBoard* soundboard)
{
    this->soundBoard = soundboard;
};

                        </code>
                    </pre>
                </div>
                
                <div>
                    <h2>Последствия применения паттерна</h2>
                    <h3>Преимущества</h3>
                    <ol>
                        <li>
                            снижает число пораждаемых подкалссов. Медиатор локализует 
                            поведение, которое в противном случае пришлось бы разделять
                            между несколькими объектами;
                        </li>
                        <li>
                            устраняет связанность между коллегами. Медиатор обеспечивает слабую связанность коллег.
                            Изменять классы "коллег" и классы "Медиаторы" можно независимо друг от друга.
                        </li>
                        <li>
                            упрощает протоколы взаимодействия с объектами, абстрагирует способ
                            кооперирования объектов.
                        </li>
                     </ol>
                    <h3>Недостатки</h3>
                    <ol>
                        <li>
                            Централизует управление, перенося сложности взаимодействия в класс "Посредник".
                            В итоге получается монолитный класс, который труднее поддерживать с течением времени.
                        </li>
                    </ol>
                </div>

            </div>
    </div>   
</body>