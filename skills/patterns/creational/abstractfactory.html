<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" href="/css/newstyle.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nunito">
<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
</head>
<body>
    <div class="mainText">

        <div class="learnedSkills">
            <div class="routes">
                <div class="route">
                    <h2><a href="/index.html">На главную</a></h2>
                </div>
                
                <div class="route">
                    <h2><a href="../intro.html">Обратно</a></h2>
                </div>
            </div>
            <div class="СppAndPg">
                <h1>Abstract factory</h1>
                <div>
                    <h2>Что предоставляет?</h2>
                    Предоставляет интрфейс для создания семейств связанных объектов без спецификации их конкретных классов.
                </div>

                <div>
                    <h2>Применимость</h2>
                    <ol>
                        <li>
                            Система должна быть независимой от того, как ее объекты (продукты) были созданы, составлены и представлены.
                        </li>
                        <li>
                            Система должна быть настроена с использованием одного из нескольких семейств продуктов.
                        </li>
                        <li>
                            Семейство связанных объектов (продуктов) предназначено для совместного их использования, и вам необходимо обеспечить соблюдение этого ограничения.
                        </li>
                        <li>
                            Вы хотели бы показать только интерфейс для создания объектов, а не их реализацию.
                        </li>
                    </ol>
                </div>

                <div>
                    <h2>Мотивация</h2>
                    Представим, что мы создаем модель сети для поездов для различных локаций. В данной модели имеются три основные сущности:
                    <ol>
                        <li>Поезд</li>
                        <li>Станция</li>
                        <li>Железнодорожные пути</li>
                    </ol>

                    Каждая из вышеприведенных сущностей может иметь различные подвиды: поезд может быть пассажирским, грузовым или поезд спецназначения;
                    Могут быть виды станций, которые принимают только пассажиров или только товары. 
                    То есть у нас имеется семейство некоторых сущностей.

                    То есть, имеются следующие классы:
                    <div>
                        <pre class="prettyprint">
<code>

class AbstractTrain
{
public :
    virtual void  toString() = 0;
};

class AbstractStation
{
protected:
     std::list roadsFromStation;
public:
        virtual void toString() = 0;
};

class AbstractTrainRoad
{
public: 
    virtual void  toString() = 0;
};




</code>
                        </pre>
                    </div>
                    
                    Каждая локация может иметь несколько моделей сети поездов, которую в свою очередь имеют некоторый тип станций, поездов, и железнодорожных путей. 
                    Но может возникнуть ситуация, когда локация захочет сменить определенную модель сети поездов. Тут могут возникнуть следующие проблемы:
                    <ol>
                        <li>
                            Создание сущностей может быть размазано по всему коду, что затруднит внесение изменений.
                        </li>
                        <li>
                            Изменение одной модели сети может повлечь за собой внесение изменений сущностей, которая она содержит.
                        </li>
                    </ol>

                    Один из способов решить данную проблему -- паттерн Abstract Factory. Суть паттерна заключается в создании класса, который инкапсулирует создание семейств объектов.
                    Главное достоинство подобного шаблона -- гибкость. Нам нужно будет заменить одну строчку, в случае изменений спецификаций. Рассмотрим подробнее. 
                </div>

                <div>
                    <h2>Схема</h2>
                    Ниже представлена схема паттерна Abstract Factory:
                    <div>
                        <img class="schemaImage" src="/images/patterns/abstractFactory/schema.png" alt="Схема">
                    </div>
                    <br>
                    У нас имеются некоторые классы <i>AbstractProductA</i> и <i>AbstractProductB</i>, которые представляет некоторое множество связанных классов.

                    Абстрактный класс или интерфейс <i>AbstractFactory</i> определяет интерфейс для создания семейства объектов.
                    Методы, которые отвечают за создание сущностей, мы определим в соответствующих наследующихся классах.   

                    Для создания сущностей, клиент обращается к методам Абстрактной Фабрики. Заметьте, что клиент ничего не знает о том, как они создаются.
                    
                </div>

                <div>
                    <h2>Source code example</h2>
                    Полный код примера можно увидеть <a href="https://github.com/eduAlexandrPirogov/Patterns/tree/main/abstractFactory">на гитхабе</a>.

                    А ниже приведен пример двух конкретных классов, наследующихся от Абстрактной Фабрики:
                    <div>
                        <pre class="prettyprint">
                            <code>
class ArmyTrainNetworkFactory : public AbstractFactory
{
public :
    virtual void createTrain()
    {
        return new ArmyTrain;
     };

     virtual void createRoad() 
     {
         return new IronTrainRoad;
     };


     virtual void createStation() 
     {
         return new ArmyStation;
     };
 };


 class GovernemtTrainNetworkFactory : public AbstractFactory
 {
 public :
     virtual void createTrain() 
     {
         return new GovernmentTrain;
     };

     virtual void createRoad() 
     {
         return new HighSpeedTrainRoad;
     };
 
     virtual void createStation() 
     {
         return new GovermentStation;
     };
 };

 
                            </code>
                        </pre>
                    </div>

                        Каждая фабрика создает свою модель сети поездов. При этом, нам достаточно изменить одну строку, заменив фабрику, если изменятся спецификации.
                </div>

                <div>
                    <h2>Последствия применения паттерна</h2>
                    <h3>Преимущества</h3>
                    <ol>
                        <li>
                            Абстрактная фабрика инкапсулирует ответственность и процесс создания объектов и изолирует клиентов от классов реализации.
                        </li>
                        <li>
                            Абстрактная фабрика позволяет легко обмениваться семействами объектов, изменяя конкретную фабрику.
                        </li>
                        <li>
                            Абстрактная фабрика способствует согласованности между семействами объектов.
                        </li>
                    </ol>
                    
                    <h3>Недостатки</h3>
                    <ol>
                        <li>
                            Поддерживать новые типы семейств объектов сложно. Если мы будем расширять абстрактную фабрику, мы должны определить все методы подклассов.
                        </li>
                        <li>
                            Большое количество семейств объектов приводит к большому количеству методов абстрактной фабрики.
                        </li>
                    </ol>
                </div>

            </div>
    </div>   
</body>