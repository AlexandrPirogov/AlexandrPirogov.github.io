<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" href="/css/newstyle.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nunito">
<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
</head>
<body>
    <div class="mainText">

        <div class="learnedSkills">
            <div class="routes">
                <div class="route">
                    <h2><a href="/index.html">На главную</a></h2>
                </div>
                
                <div class="route">
                    <h2><a href="../intro.html">Обратно</a></h2>
                </div>
            </div>
            <div class="СppAndPg">
                <h1>Adapter</h1>
                <div>
                    <h2>Что предоставляет?</h2>
                    Преобразует интерфейс класса в другой интерфейс, ожидаемый клиентами. Адаптер позволяет классам работать вместе, что иначе было бы невозможно из-за несовместимых интерфейсов.
                </div>

                <div>
                    <h2>Применимость</h2>
                    Применяйте данный паттерн когда:
                    <ol>
                        <li>
                            хотите использовать существующий класс, но его интерфейс не соответствует вашим потребностям.
                        </li>
                        <li>
                            собираетесь создавать повторно используемый класс, который должен
                            взаимодействовать с заранее неизвестными или не связанными с ним классами, имеющими
                            несовместимый интерфейс
                        </li>
                    </ol>
                </div>

                <div>
                    <h2>Мотивация</h2>
                </div>
                <div>
                    <p>
                        Иногда существующий класс из библиотеку/иного кода, спроектированный для 
                        повторного использования, не удается использовать только потому, что его 
                        интерфейс не соответствует тому, который нужен конкретному клиенту.
                    </p>
                    <p>
                        
                    </p>
                </div>
                
                
                <div>
                    <h2>Схема</h2>
                    <img class="schemaImage" src="/images/patterns/structural/adapter/adapterschema.png" alt="">
                </div>


                <div>
                    <h2>Source code example</h2>
                    Полный код примера можно увидеть <a href="https://github.com/eduAlexandrPirogov/Patterns/blob/main/structureal/adapter/README.md">на гитхабе</a>.

                    </div>
                </div>
                <div>
                    <pre class="prettyprint">
                        <code>
class Notebook
{
    std::list<std::string>  notes;
    public:
        Notebook() = default;

        virtual void write(char* text)
        {
            notes.push_back(std::string{text});
        };

        virtual void showNotes()
        {
            std::cout << "Showing notes from Notebook:\n";
            for(const auto& note : notes)
                std::cout << note << '\n';
            std::cout << "It's over\n";
        };
};


class Ipad
{
    std::list<std::string>  notes;
    bool isWorking;
    public:
        Ipad() : isWorking(false) {};

        void turnOn()
        {
            std::cout << "Turning on Ipad...\n";
            isWorking = true;
        };

        void turnOff()
        {
            std::cout << "Turning off Ipad...\n";
            isWorking = false;
        };

        void saveNote(char* text)
        {
            std::cout << "Writing note to Ipad...\n";
            notes.push_back(std::string{text});
        };

        void displayNotes()
        {
            std::cout << "Showing notes from Ipad:\n";
            for(const auto& note : notes)
                std::cout << note << '\n';
            std::cout << "It's over\n";
        };
};

class IpadApater : Ipad, public Notebook
{
    public:
        void showNotes()
        {
            Ipad::displayNotes();
        };

        void write(char* text)
        {
            Ipad::turnOn();
            Ipad::saveNote(text);
            Ipad::turnOff();
        };
};

class AnotherIpadApater : Ipad, public Notebook
{
    Ipad* ipadToAdapt = 0;
    public:
        AnotherIpadApater(Ipad* toAdapt) : ipadToAdapt(toAdapt){};

        void showNotes()
        {
            ipadToAdapt->displayNotes();
        };

        void write(char* text)
        {
            ipadToAdapt->turnOn();
            ipadToAdapt->saveNote(text);
            ipadToAdapt->turnOff();
        };
};

int main()
{
    Notebook* notebook = new Notebook{};
    notebook->write("Buy apples");
    notebook->write("Learn pattern \"Adapter\"");

    Notebook* ipad = new IpadApater();
    ipad->write("Watch film");
    ipad->write("Meet old friend");


    Ipad* ipadAir = new Ipad();
    AnotherIpadApater* adapter = new AnotherIpadApater(ipadAir);
    adapter->write("Go for a run");
    adapter->write("Play football");

    std::list<Notebook*> notebooks;
    notebooks.push_back(notebook);
    notebooks.push_back(ipad);
    notebooks.push_back(adapter);

    for(const auto* item : notebooks)
        notebook->showNotes();
};
                        </code>
                    </pre>
                </div>
                <div>
                    
                </div>

                <div>
                    <h2>Последствия применения паттерна</h2>
                    <h3>Преимущества</h3>
                        <ol>
                            <li>
                                Отделение реализации от интерфейса. Реализация больше не имеет постоянной привязки
                                к интерфейсу, и реализацию абстракции можно конфигурироватьв ран-тайме.
                            </li>
                            <li>
                                Повышение степение расширяемости. Можно расширять независимые иерархии
                                классов Abstarction и Implementor.
                            </li>
                            <li>
                                Сокрытие деталей реализации от клиентов.
                            </li>
                        </ol>
                    <h3>Недостатки</h3>
                    <ol>
                        <li>
                            Из-за наследования от цели, к которой адаптируется интерфейс разрастается иерархия классов.
                        </li>
                    </ol>
                </div>


            </div>
    </div>   
</body>