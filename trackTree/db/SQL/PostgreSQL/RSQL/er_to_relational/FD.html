<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="/css/style.css">
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</head>
<body>
    <div class="mainText">
        <h1>Функциональная зависимость</h1>

            Независимо от способа создания реляционной схемы, зачастую представляется возможным повысить качество проекта, реализуя определенные типы ограничений.
            К набиолее важным типам ограничений, применяемых в контексте проекта реляционной базы данных, относится ограчничение уникальности, так называемое 
            функциональное ограничение (functional dependency -- FD). Реализация ограничений этого типа жизненно важна для обеспечения возможности внесения изменений 
            в схему базы данных с целью устранения информацинной избыточности.

            <h2>Определение функциональной зависимости</h2>
            
            Функциональная зависимость для отношения R -- это утверждение следующего вида: "Если два кортежа отношения R совпадают в атрибутах A1,...An 
            (т.е. кортежи обладают одинаковыми значениями компонентов для каждого из названных атрибутов), то они должны совпадать и в другом атрибуте B".

            Формально такая FD записывается как A1, A2...An --> B и свидетельствует, что "A1,A2,...An функционально обуславливают B".
            Если несколько атрибутов, A1, A2, ...An, функционально обуславливают более одного атрибута, то есть
            <br><br> A1 A2 ... An --> B1
            <br>A1 A2 ... An --> B2
            <br>...
            <br>A1 A2 ... An --> Bm
            <br>
            <br>позволяется использовать сокращенное представление набора таких FD:

            <br><br>A1 A2 ... An --> B1 B2 ... Bm
            <div class="example">
                Диаграмма FD выглядит следующим образом
                <div class="exampleImage">
                   <img src="/images/db/SQL/PosgreSQL/4chapter/DiagramFD.png" alt="">
                </div>
            </div>

            Неформально говоря, выражение A1 A2 ... An --> B называют <b>функциональной</b> зависимостью, поскольу оно определяет функцию, которая в качестве
            параметров принимает список значений, по одному на каждый из атрибутов A1,A2, ... An и возвращает строго определённое значение 
            (либо не возвращает значения вовсе) для атрибута B. 

            <div class="example">
                В данном примере несколько функциональных зависимостей (положим, что в одном турнире не могут встречаться клубы с одинаковыми цветами и названиями):
                <br> Название Турнир --> Стадион
                <br> Название Турнир --> Цвет
                <br> Название Турнир --> Страна
                <br> Название Турнир --> Трофеи
                <br> Название Турнир --> Турнир
                <br><br> Мы вправе сократить функциональную зависимость : <br><br>
                Название Турнир --> Стадион, Трофеи, Цвет, Старна, Турнир

                <div class="exampleImage">
                    <img src="/images/db/SQL/PosgreSQL/4chapter/fdKeys.png" alt="">
                </div>

                Однако, выражение Название Турнир --> Игрок не явлется функциональной зависимостью, так как каждой сущности "Футбольный клубь" будет соответствовать
                несколько игроков.
            </div>

            <h2>Ключи отношений</h2>

            Говорят, что множество вида {A1, A2, ... An}, состоящее из одного или нескольких атрибутов, является ключом отношения R, если выполняются следующие условия:

            <ol>
                <li>Атрибуты A1, A2, ... An функционально обуславливают все остальные атрибуты отношения, т.е. ситуация, когда два различных кортежа
                    R совпадают во всех атрибутах A1, A2, ... An, невозможна.
                </li>
                <li>
                    Ни одно из допустимых подмножеств множества {A1, A2, ... An} атрибутов не является функциональным обоснованием всех остальных атрибутов 
                    отношения R, т.е. ключ <i>минимален</i>.
                </li>
            </ol>

            
            <div class="example">
                Атрибуты вышеприведённого примера {Название, Турнир, Игрок} образуют ключ для отношения "Футбольный клуб".
                Для начала, мы должны показать, что атрибуты функционально обуславливают все остальные атрибуты. Действительно, двух кортежей с одинаковыми 
                атрибутами {Название, Турнир, Игрок} быть не может (Положим, что игроков с одинаковыми именами не имеется в одном клубе).
                <p>
                    Теперь докажем, что ни одно из подмножеств множества ключа {Название, Турнир, Игрок} не в состоянии функционально обусловить все остальные атрибуты.
                    Действительно, клубы с одинаковым названием могут встречаться в разных лигах, а игроки с одинаковыми именами могут играть в разных клубах,
                    а в одном турнире могут играть несколько игроков с одинакоыми именами. 
                    Рассмотрим подмножества {Название, Турнир}, {Название, Игрок}, {Турнир, Игрок}.

                    <ol>
                        <li>
                            {Название, Турнир}. В разных турнирах в клубах с одинаковыми названиями могут играть игроки с одинаковыми именами. 
                        </li>
                        <li>
                            {Название, Игрок}. Подобно первому примеру, в двух клубах с одинаковыми названиями могут играть два игрока с одинаковыми именами, но в разных турнирах.
                        </li>
                        <li>
                            {Турнир, Игрок}. В одном турнире, игроки, с одинаковыми именами, могут играть за разные клубы.
                        </li>
                    </ol>

                    Таким образом, атрибуты {Название, Турнир, Игрок} -- ключ к отношению "Футбольный клуб".
                </p> 

            Для отношения может быть создано несколько ключей. В такой ситуации одному из них отводится роль <i>первичного ключа</i> (<i>primary key</i>).
            Выбор первичного ключа способ воздействовать на определенные свойства реализации баз данных (напомер, какие образом отношение хранится на диске).
            Вот одно полезное правило:
            <ul>
                <li>В тексте схемы отношения атрибуты первочного ключа надлежит подчеркнуть</li>
            </ul>
            </div>

        <div class="part">
            <h2>Суперключи</h2>

            Множество атрибутов, содержащее ключ в качестве подмножества, называют <i>суперключом</i>. Некоторые суперключи не обладают свойством минимальности,
            хотя каждый суперключ удовлетворяет первому требованию, предъявляемому к ключам: он фукционально обуславливает все остальные атрибуты отношения.

            <div class="example">
               Для нашего примера, суперключом является не только {Название, Турнир, Игрок} , но и любое его надмножества, например: {Название, Турнир, Игрок, Страна} 
            </div>
        </div>

        <div class="part">
            <h2>Выбор ключей для отношения</h2>

            Первое правило, касающееся выбора ключей отношения, звучит так:

            <ul>
                <li>Если отношение получено на основе множества сущностей, ключ отношения формируется из ключевых атрибутов множества сущностей.</li>
            </ul>

            Второе правило выбора ключей отношения касается бинарных связей. Если отношение R создается на основе связи, на состав множества ключей отношения 
            оказывает влияние свойство множественности связи. Существуют три варианта правила:

            <ul>
                <li>
                    Если связь относится к типу "многие ко многим", ключами отношения R становятся ключевые атрибуты обоих множеств сущностей, соединяемых связью
                </li>
                <li>
                    Если связь относится к типу "многие к одному" и соединяет множества сущностей Е1 и Е2 в направление от Е1 к Е2, ключами отношения R должны быть
                    ключевые атрибуты множества E1 (но не Е2)
                </li>
                <li>
                    Если связь относится к типу "один к одному", ключевыми атрибутами отношения R могут быть ключи любого из соединямых множеств.
                </li>
            </ul>

            По поводу тернарных связей можно гарантирвоать справедливость утверждения следующего вида:
            <ul>
                <li>
                    Если многостороняя связь R содержит стрелку, направленную к множеству сущностей Е, существует по меньшей мере один ключ для соответствующего отношения,
                    который противоречит ключу Е
                </li>
            </ul>
            
            <div class="example">
                На основе первого правила:
                <ol>
                    <li>Футболист {<u>Номер</u>, <u>Имя</u>, Позиция}</li>
                    <li>Футболньый клуб {<u>Название</u>, Стадион, Цвет}</li>
                </ol>

                <br>
                На основе  второго правила: 
                <ol>
                    <li>ФутболистВКлубе {<u>Номер</u>, <u>Имя</u>, НазваниеКлуба}</li>
                </ol>
                <div class="exampleImage">
                   <img src="/images/db/SQL/PosgreSQL/4chapter/erToRelation.png" alt="">
                </div>
            </div>
        </div>

    </div>
    </div>
</body>