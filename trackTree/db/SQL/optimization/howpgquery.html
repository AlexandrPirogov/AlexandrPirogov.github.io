<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" href="./css/style.css">
</head>
<body>
    <div class="mainText">
        <h1>Как PostgreSQL выполняет запросы. Теория.</h1>
    
        <p>
            Чтобы получить результаты запроса, PostgreSQL выполняет следующие шаги:
            <ol>
                <li>Комплилирует и преобразует инструкцию SQL в выражение, состоящее из логических операций высокого уровня,
                    называемый <i>логический план</i>
                </li>
                <li>Оптимизирует логический план и превращает его в план выполнения</li>
                <li>выполняет (интерпретирует) план и возвращает результаты</li>
            </ol>
        </p>
    </div>

    <div>
        <h2>Компиляция, оптимизация и выполнение</h2>
        <p>
            При компиляции, в отличие от императивных языков программирования, исходный код состоит из высокоуровневых операций,
            которые остаются декларативными. 
        </p>
        <p>
            Инструкции по выполнению появляются при оптимизации:
            <ol>
                <li>Преобразование логических операций на алгоритмы выполнения</li>
                <li>Измена порядок выполнения логических операций</li>
            </ol>

            Один и тот же запрос может быть представлен несколькими способами, но требующими существенно разного количества вычислительных ресурсов
            для выполнения.
        </p>
        <p>
            Результатом работы оптимизатора является выражение, содержащее физические операции. Это выражение называется физическим планом
            выполнения. Далее, план выполнения интерпритируется движком выполнения запроса.
        </p>
    </div>

    <div>
        <h2>Основные моменты реляционной теории</h2>
         <ol>
             <li>Фильтрация -- принимает в качестве аргумента отношение и возвращает отношение с кортежами, удовлетворяющие некоторому 
                 условию (фильтру).
             </li>
             <li>
                 Проекци -- принимае в качестве аргумента отношение и удаляет некоторые атрибуты.
             </li>
             <li>
                 Произведение -- декартово произведение одного отношения на другое
             </li>
         </ol>

        Также имеется элемент реляционной теории, которые нужен для оптимизации -- <i>эквивалентность</i>.

        <ol>
            <li>коммутативность -- JOIN(R,S) = JOIN (S, R). Порядок двух отношений не важен</li>
            <li>ассоциативность -- JOIN(R, JOIN(S, T) = JOIN (JOIN(R,S), T). Мы можем соединить сначала S и T, а затем R, или, сначала R и S, а затем T.
                Результат не изменится.
            </li>
            <li>дистрибутивность -- JOIN(R, UNION(S, T)) = UNION(JOIN(R, S), JOIN(R, T)). Если мы соединим отношение с объединением двух других
                отношений, результат будет таким же, как если бы мы выполнили два соединения, R JOIN S и R JOIN T, по отдельности, а затем
                объединили бы результаты.
            </li>
        </ol>
    </div>

    <div>
        <p>Способность оптимизатора создавать эффективный план выполнения зависит от двух факторов:
            <ol>
                <li>богатый набор эквивалентностей обеспечивает большое пространоство эквивалентных выражений</li>
                <li>реляционные операции не имеют побочных эффектов, таких как временные таблицы, то есть, единственное, что они порождают 
                    -- это результат операции.
                </li>
            </ol>
        </p>
        <p>
            Чтобы сделать запрос исполняемым, планироващие заменяет логические операции физическими (алгоритмами), а общее время выполнения
            запроса зависит от того, какие выбраны алгоритмы и правильно ли они выбраны.
        </p>
    </div>
        
    <div>
        <h2>Алгоритмы</h2>

        <p>
            Для подбора алгоритмов, оптимизатор смотри на внутренние факторы. Поскольку факторы разнятся от одних комплектующих в другим, все 
            операции сводятся в одну функцию стоимости: чем ниже стоимость -- тем лучше.
        </p>
        <p>
            Чтобы начать выполнение запроса, движок должен извлечь сохраненные данные. Эффективность таких операций зависит от соотношения количества строк,
            составляющих результат операции, к общему количеству строк в сохраненной таблице. Такое соотношение называется <i>селективностью</i>. 
            Выбор алгоритма для определенной операции чтения зависит от селективности фильтров, которые могут применяться одновременно.
        </p>
        <p>
            Данные хранятся в файлах на жестких дисках. Любой файл, используемый для объектов баз, данных делится на блоки одинаковой длины: по умолчанию
            PosgreSQL использует блоки по 8192 байта каждый. Блок -- единица, которая передается между жестким диском и оперативной памятью, а количество операций
            ввода-вывода, необходимые для выполнения доступа к данным, равно количеству блоков, которые читаются и записываются.
        </p>
        <p>
            Объекты баз данные состоят из логических элементов(строки, индексные записи и т.д), находящиеся в блоках. Мелкие элементы могут находится в одном блоке, более крупные могут быть 
            распределены между несколькими блоками.
        </p>

        <p>
            Последовательно сканирование -- при полном сканировании движок БД последовательно считывает все строки в таблице и для каждой строки проверяет условие фильтрации.
        </p>
        <p>
            Индексы -- объекты БД; не хранят никакой дополнительной информации, которую нельзя найти в исходной таблице. Это структура данных,
            которая позволяет определить, какие значения хранятся в строках таблицы, без необходимости чтения самой таблицы. Они хранят список указателей 
            на строки, удовлетворяющие некоторому условию.
            <br><br>
            Чтобы получить строку таблицы по указателю, необходимо прочитать блок, содержащий эту строку. Основная структура данных таблицы -- это куча,
            то есть строки хранятся неупорядоченно. Есть две отдельные физические операции для получения строк с помощью индексов: индексное сканирование 
            (index scan) и сканирование по битовой карте (bitmap heap scan). 
        </p>
        <p>
            При индексном сканировании, движок БД считывает одну за другой все записи индекса, которые удовлетворяют условию фильтрации, и в этом же порядке извлекает
            блоки. Поскольку базовая таблица представляет собой кучу, несколько записей индекса могут указывать на один и тот же блок. Чтобы избежать многократного
            чтения одного и того же блока, в PosgreSQL реализована операция сканирования по битовой карте, которая создает битовую карту блоков, содержащих 
            необходимые строки, где потом этим строки фильтруются. 
            <br><br>
            Стоимостная модель алгоритма: чем ниже значение селективности, т.е. все строки, удовлетворяющие условию фильтрации, будут располагаться в различных
            блоках, то стоимость будет пропорциональна количеству возвращаемых строк. Для больших значение селективности количество обрабатываемых блоков приближется
            к общему количеству блоков, стоимость становится выше, чем стоимость полного сканирования, поскольку для доступа к индексу необходимы ресурсы.
        </p>
        <p>Сканирование полгого индекса. Если для фильтрации требуются только столбцы, которые включает в себя индекс, то алгоритм считывает данные из 
            индекса и применяет оставшиеся условия фильтрации.
        </p>

    </div>

    <div>
        <h2>Индексы</h2>
        Индекс по способу использоване есть структура данных, которая:
        <ol>
            <li>"Избыточная" -- означает, что индекс можно удалить без потери данных и восстановить по информации, хранящейся в таблице.</li>
            <li>Невидима для приложения -- приложение не знает о существовании индекса.</li>
            <li>Предназначеня для ускорения выбора данных по определенным критериям</li>
        </ol>
        Поскольку индекс избыточен, он должен обновляться при обновлении данных таблицы. 

        <p>
            Хотя индексные структуры могут значительно различаться, для разных типов индексов, ускорение всегда достигается за счёт быстрой проверки
            некоторых услових фильтрации.
        </p>
        <p>
            Индекс состоит из индексного ключа и значения, которое совпадает со значение индексированного атрибута. Если значение атрибута 
            в таблице повторяется несколько раз, то значение индексного ключа так же повторится несколько раз для указателя на соответствующую строку таблцы.
        </p>
    </div>

    <div>
        <h2>Виды индексов</h2>

        <h3>В-деревья</h3>
        <p>
            Структура  B-дерева -- дерево. Состоит из иерархически организованных узлов, связанных с блоками, хранящимися на диске.
            Листовые узлы содержат записи индекса, состоящие из индексного ключа и указателя на строку таблицы. 
            Нелистовые узлы содержат записи, состоящие из наименьшего ключа в блоке, расположенном на следующем уровне, и указателя на этот блок.
            Все записи упорядочены, и в каждом блоке используется не менее половины доступного объёма. 
            <br><br>
            Поиск ключа К наинается с корневого узла В-дерева. Во время поиска по блоку будет найден самый большой ключ P, не привышающий K, и затем
            поиск продолжается в блоке, на который ссылается указатель, связанный с Р. Поиск продолжается, пока не дойдём до листового узла, где указатели 
            ссылаются на строки таблицы. 
        </p>

        <h3>Битовые карты</h3>
        <p>
            Битовая карта -- вид индекса для компактного представления свойств табличных данных. Чаще всего битовая карта содержит по одному биту для 
            каждого блока (8192 байта). Значение бита равно 1, если блок обладает нужным свойством и 0, если нет.
        </p>
        <h3>Другие виды индексов</h3>
        <p>
            Хэш-индекс -- использует хеш функцию для вычисления адреса индексного блока, содержащего индексный ключ. Для условия равенства этот тип 
            работает быстрее B-0дерева, но бесполезен для запросов по диапазону. Стоимостная оценка не зависит от размера по индексу.
        </p>
        <p>
            R-дерево -- поиск по пространственным данным. 
        </p>
    </div>

</body>